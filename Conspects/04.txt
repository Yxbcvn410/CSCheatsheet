И вот мы написали первое "параллельное" приложение. Но проблема ---
		оно абсоолютно бесползено.

Всвязи с этим поговорим с о коммуникаторных функциях.

Каждый процесс вообще может задаться вопросом, а  какое место в множестве	связанных коммуникационных сетей он занимает.

это осуществляет функция --- int MPI_Comm_rank (MPI_Comm comm, int *rank)
	узнает номер текущего процесса.

чтобы узнать мощность коммуникационного множества:
		int MPI_Comm_size(MPI_Comm comm, int *size)

=========================
Переходим ко второй группе команд: передачи сообщений между процессами

Передается массив однородной информации, нумерующий от нуля до N
	N достаточно большой, чтобы до него не дойти.

mpi рабоает на "среднем" уровне, и трудно переносится с машины на машину
	поэтому нужно читать про архитектуру, под которою всё пишется.


char MPI_CHAR

int MPI_INT

double MPI_DOUBLE

Потенциально можно написать свой тип данных, запомним.

=====================================
Сообщения в mpi можно указать аттрибут tag для фильтровки потока
	сообщений: принятия нужных, отсеивания ненужных.


MPI_Send (void *buf, int count, MPI_Datatype type, 
				int dest, int tag,  MPI_Comm comm )

	buf ---	адрес начала сообщения
	count --- скольо лежит в массиве
	type --- тип передаваемых данных
	dest --- адрес цели (внутри множестве)
	tag --- тэг сообщения
	comm --- множество процессов


MPI_Recv (void *buf, int maxcount, MPI_Datatype type, 
				int source, int tag,  MPI_Comm comm, MPI_Status *st )

	buf ---	адрес памяти приниамющей сообщение
	maxcount --- максимальный размер принимаемого массива
	type --- тип получаемых  данных
	source --- адрес передатчика, может принять MPI_ANY_SOURCE
	tag --- тэг сообщения, может принять MPI_ANY_TAG
	comm --- множество процессов
	MPI_Status имеет следующие поля: MPI_TAG, MPI_SOURCE, MPI_ERROR.

процесс впадает в ожидание, пока не получить сообщение с нужным
	source и tag.


MPI_Get_count (MPI_Status *st, MPI_Datatype type, int *count) --- узнать,
			сколько пришло.

Задача. Запускаем сколько-то процессов. 0 передает int(=0) 1 следующий
	прибавляет свой ранк и передаёт дальше по кругу, до 0.
