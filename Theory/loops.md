# Распараллеливание простых (невложенных) циклов

Исторически имеем три вида циклов:

* Со счётчиком, типа `for` (итераторы - по сути, то же самое)

* С пред-условием, типа `while` - условие проверяется перед каждой итерацией

* С пост-условием, типа `do .. while` - условие проверяется после каждой итерации

Мы рассматриваем только циклы первого типа. В Фортране обозначаем так:

```fortran
do i=b, e, s
	# Do something
end do
```

Здесь `b, e, s` - начальное, конечное значение и шаг (если он равен 1, его можно опустить). Эти три числа задают **итерационное пространство**.

Соответственно, распараллелить этот цикл - это разделить итерацоиннное пространство на несколько исполнителей. Это можно сделать не всегда - если есть зависимость по данным от предыдущих итераций. 
В общем случае - если мы на одной итерации в ячейку пишем, а позже из неё читаем.

Чтобы найти такие зависимости, нужно решить Диофантово уравнение. Если оно имеет решение, то оператор, где в ячейку данные записываются - **источник зависимости**, а где считываются - **сток зависимости**.
Можем ввести величину D - разность итераций между источником и стоком. Её называем **расстояние зависимости**.

Тут можно рассмотреть три случая:

* D > 0
	Тогда это называем истинной **зависимостью**. Задаётся естественное ограничение на количество исполнителей

* D < 0
	Тогда это называется **антизависимостью**.
	Полезной может быть **барьерная синхронизация** - исполнители вызывают нужную функцию и ждут, пока её не вызвали остальные.

* D = 0
	Тогда на исполнение собственно цикла это не влияет - не можем определить, истинная ли это зависимость или антизависимость.
	Называем это **loop independent dependence**.

### Пример

```fortran
do i=1, u
	a(i) = d(i) + 5 * i
	c(i) = 2 * a(2 * i)
end do
```

Расстояние зависимости неопределённое, но всегда отрицательное.

----

[На главную](../Readme.md)