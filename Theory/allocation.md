# Назначение и оркестровка

Назначение - распределение задач по виртуальным исполнителям.

- Можно делать статически (на этапе написания кода) или динамически (в процессе выполнения)
- Задачи:
	- Балансировка (примерно одинаковая нагрузка на всех исполнителей)
	- Минимизация взаимодействия между исполнителями (ибо накладные расходы)

## Немного схем для динамического назначения

### Master-slave

Разделили программу на ярусы - последовательные, параллельные.

Есть один Master и много Worker'ов. Последовательный ярус считает Master один. 
Перед параллельным ярусом Master рассылает информацию Worker'ам, Worker'ы считают, Master собирает информацию в конце.
Сам Master засекает время, изменяет в зависимости от этого балансировку.

Подход неудачен в том плане, что требуется много обмена данных. 
**Можно модифицировать этот подход**, если последовательный этап выполняется всеми, а после параллельного нужные данные копируются на всех исполнителей.
Это уменьшит накладные расходы на передачу данных между исполнителями.

### Pool of works

Есть много отдельных работ, с зависимостями по данным. Они организованы в своеобразный ориентированный граф. 
Если работа "открыта", т. е. необходимые данные вычислены, освободившийся исполнитель может начать её выполнять, пометив "занятой".
А после исполнения работа помечается завершённой, что "открывает" следующую работу.

### Competition

Внезапно. Если методом Ньютона искать корни, хорошей идеей будет разделить отрезок, на котором ищутся корни, на нескольких исполнителей.



----

[На главную](../Readme.md)