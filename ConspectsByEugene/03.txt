Распарелеллевание алгоритмов. Асимптотический анализ.
===================================

Как сравнивать алгоритмы?

	-> для большинства залач мат.  моедлирования существуют параметры масштаба
	-> параметры масштаба и параметры размерности -- это не одно и то же
	-> термин "размерность" связан с количеством независимых или фазовых переменных
	-> параметры масштаба связаны с объёмом входных данных

Параметры масштаба задачи влияют на время работы различных алгоритмов и на объём 	других ресурсов.


Основные принципы сравнения алгоритмов:
	1) должно сравнивать времена работы двух алгоритмов для одинаковых масштабов.
	2) нужно предложить модель вычислительной системы
	3) времена работы при малых масштабах обычно малоинтересны
	4) нужно анализировать скорость роста, а не некоторые конкретные значения

RAM (random access machine)
	1) один процесс с одним ядром
	2) ячейки памяти доступны в произвольном порядке
	3) время доступа к памяти есть Θ(1) назвисимо от того, чтениние или запись
	4) время выполнения любой базовой операции не зависит от значения аргументов.

Для простоты такие базовые оперции оценивают временем Θ(1)

Расммотрм множество данных S.
Каждый элемент массива хранит информацию, снабженную ключом. 
Все ключи в массиве различны.


----------------------------------------
Задача поиска по ключу алгоритм перебора:
Время на проверку одного элемента --- Θ(1).
Время на решение задачи при наихудших начальных данных T(n) = n Θ(1) = Θ(n).


-----------------------
Задача сортировки:
Алгоритм слияния:

	Шаг 1 --- если |S|=1, то множество отсортировано.
		Иначе разобьём на две части одинаковой длины.
	Шаг 2 --- каждое Si рекурсивно снова применяем Шаг 1.
	Шаг 3 --- отсортированные Si сливаем в одно множество с сохранением порядка

А теперь про время:
	Шаг 1 --- множество отсортировано:  T1(n) = Θ(1). Иначе разобьём: тоже Θ(1).

	Шаг 2 --- Время сортировки каждого Si: T(|S_i|) = T(|S|/2) + ... Итого: 2T(n/2)

	Шаг 3 --- T3 (n) = c_0 n


Дальше выписываем все и суммируем: T(n) = 2T(n/2) + c_0 n


Проведя алгоритм упростим: T(n) = n T(1) + (log_2 n) c_0 n = Θ(n log n).



mpicc 
mpic++



#!/bin/bash --- выбор шелла

#PBS -l walltime=00:01:00,nodes=7:ppn=2 --- заказываем минуту (0-10 мин)
	семь узлов (<=7), ppn -- колличество ядер на одном узле (0-4 штук)

#PBS -N example_job --- задать имя задачи, выбираем как хотим.

#PBS -q batch --- без имзенений, указаение очереди, в нашем случае "batch"

cd $PBS_O_WORKDIR

mpirun -- hostfile $PBS_NODEFILE -np 14 ./a.out --- 
		np это использовать количество процессов


Как всё это ставиться в очередь?

команада --- qsub, для примера qsub job.sh

команда --- qstat, мониторинг заданий в очереди

команда --- qdel, удаление задание из очереди


mpicc имя_исходника -o имя_исполняемого
